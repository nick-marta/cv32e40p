// Code your testbench here
// or browse Examples
`timescale 1ns/1ps

module cv32e40p_alu_tb;
  import cv32e40p_pkg::*;

  // Clock and reset
  logic clk;
  logic rst_n;

  // ALU inputs
  alu_opcode_e   operator_i;
  logic          enable_i;
  logic  [31:0]  operand_a_i;
  logic  [31:0]  operand_b_i;
  logic  [31:0]  operand_c_i;
  logic  [1:0]   vector_mode_i;
  logic  [4:0]   bmask_a_i;
  logic  [4:0]   bmask_b_i;
  logic  [1:0]   imm_vec_ext_i;
  logic          is_clpx_i;
  logic          is_subrot_i;
  logic  [1:0]   clpx_shift_i;
  logic          ex_ready_i;

  // ALU outputs
  logic  [31:0]  result_o;
  logic          comparison_result_o;
  logic          ready_o;

  // DUT instance
  cv32e40p_alu dut (
    .clk                (clk),
    .rst_n              (rst_n),
    .enable_i           (enable_i),
    .operator_i         (operator_i),
    .operand_a_i        (operand_a_i),
    .operand_b_i        (operand_b_i),
    .vector_mode_i      (vector_mode_i),
    .bmask_a_i          (bmask_a_i),
    .bmask_b_i          (bmask_b_i),
    .imm_vec_ext_i      (imm_vec_ext_i),
    .operand_c_i        (operand_c_i),
    .is_clpx_i          (is_clpx_i),
    .is_subrot_i        (is_subrot_i),
    .clpx_shift_i       (clpx_shift_i),
    .result_o           (result_o),
    .comparison_result_o(comparison_result_o),
    .ready_o            (ready_o),
    .ex_ready_i         (ex_ready_i)
  );

  // Clock generation: 10ns period

  always #1 clk = ~clk;

  
logic [31:0] a, b, expected;
  // Simple ADD self-check
  initial begin : add_test
    $dumpfile("dump.vcd");
    $dumpvars();
    $display ("test begin");
    clk = 0;
    enable_i      = 1'b0;
    operator_i    = ALU_AND;      // arbitrary default
    operand_a_i   = '0;
    operand_b_i   = '0;
    operand_c_i   = '0;
    vector_mode_i = VEC_MODE32;   // scalar mode
    bmask_a_i     = '0;
    bmask_b_i     = '0;
    imm_vec_ext_i = '0;
    is_clpx_i     = 1'b0;
    is_subrot_i   = 1'b0;
    clpx_shift_i  = 2'b00;
    ex_ready_i    = 1'b1;         // always ready for divider

    // Apply reset
    rst_n = 1'b0;
    repeat (3) @(posedge clk);
    rst_n = 1'b1;
    
    $display ("add test start");
    // Wait until reset is deasserted
    rst_n = 1;
    @(posedge clk);

    // Test vectors
    

    a        = 32'h0000_0003;
    b        = 32'h0000_0005;
    expected = a + b;   // 8

    // Drive ALU for ADD operation in scalar mode
    operator_i    = ALU_ADD;
    vector_mode_i = VEC_MODE32;
    operand_a_i   = a;
    operand_b_i   = b;

    // Pulse enable for one cycle
    enable_i = 1'b1;
    @(posedge clk);
    enable_i = 1'b0;

    // Wait one more cycle for result
    @(posedge clk);

    // Check result
    if (result_o !== expected) begin
      $error("ADD test FAILED: %0h + %0h = %0h (expected %0h)",
             a, b, result_o, expected);
    end
    else begin
      $display("ADD test PASSED: %0h + %0h = %0h",
               a, b, result_o);
    end

    #20;
    $finish;
  end

endmodule
